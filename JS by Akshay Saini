
// How Javascript works?
   Everthing in javascript happens inside an Execution context
   Execution context is a big container in which whole javascript code is executed.
   Executuion context containing two component
   
  -----------------EXECUTION CONTEXT---------------------------
   1. Memmory/Variable Environment  2.Code/Thread of Execution
      key:value                       >>>........code
      a:10                            >>>........code
      f:{...}                         >>>........code
    ---------------EXECUTION CONTEXT---------------------------
    
    Javascript is a synchronus single-threaded language.
----------------------------------------------------------------------------------------------------------------------------------------
//How Javascript code is executedðŸ¤”? what is call stackðŸ’­?
  js code is executed line by line first it goes in memmory creation phase in that everything is undefine then second it goes inside 
  code phase then everything is run and the value is assigned to the variable/function 
  
  EXAMPLE:-----program to findout the square of number
               var n = 2;
               function square(num) {
                 var ans = num * num ;
                 return ans;
                }
                var square2 = square(n);
                var square4 = square(4);
   ------------------------------------------------------
   Memory                               Code
   n:undefine--2--4                 ------------------------
   square:{....}                    |  Memory       code     
   square2:undefine-->4             |  num :2--4       >>...
   square4:undefine-->16            |  ans :4--16      >>..
       
//what is callStack
The call stack is used by JavaScript to keep track of multiple function calls.
Example:-    function one() {
                  two();
              }
              function two() {
                   three();
              }
              function three() {
                  console.log("call stack");
               }
               
               
               |      |     |      |    |three()|       |      |      |     |     |     |
               |      |     |two() |    |two()  |       |two() |      |     |     |     |
               | one()|     |one() |    |one()  |       |one() |      |one()|     |     |
               |------|     |------|    |-------|       |------|      |-----|     |-----|
----------------------------------------------CALLSTACK------------------------------------

//what is Hosting in javascript?
  Hoisting is JavaScript's default behavior of moving all declarations to the top of the current scope (to the top of the 
  current script or the current function).
  Variables defined with let and const are hoisted to the top of the block, but not initialized.
  
  let variable before it is declared will result in a ReferenceError.
  The variable is in a "temporal dead zone" from the start of the block until it is declared.
  console.log(sum);
  let sum = a+b;    //reference error
  
  Using a const variable before it is declared, is a syntax error, so the code will simply not run.
  console.log(sum);
  const sum = 10; ///syntax error
  
  javascript doesn't host the function expressions and arrow function
  function expression: name();
                       var name = function() {
                         console.log("hello from function expression");
                        }
                        
  Arrow function : name();
                   var name = () => {
                      console.log("hello from arrow function")
                   }
---------------------------------------------UNDEFINE vs NOT DEFINED---------------------------------------------------
"undefined" indicates that a variable has been declared but not given a value,
while "not defined" indicates that a variable does not exist

console.log(a);       //undefined
var a = 10;
console.log(a);       //10
console.log(x);      //not defined
                   
In my words:- undefine means browser give the memory location to variable "a" but on line no 82 it has not assign the value that why 
              it is giving undefine and in case of x, x is not declared it is not assign any memory loaction that's why not defined.
             
--------------------------------------This in function-------------------------------------------------------------------
console.log("hello")           //hello
 
console.log(this);             //window object

function fun() {
    console.log(this);       //when we write this inside fun it will find its obj but here is no obj then it will print window obj 
}
fun()

var name = "ritu";

let obj = {
    name:"ravie",
    func1() {
        console.log(this.name);        //it is present inside obj thats why it refer that obj and print ravie
    },
    func2: () => {
       console.log(this.name);       //this is arrow fun which is not pointing this obj it will go for window obj and print ritu
    }
}
obj.func1();
obj.func2();

// console.log("hello")
 
// console.log(this);

// function fun() {
//     console.log(this);
// }
// fun()

// var name = "ritu";

// let obj = {
//     name:"ravie",
//     func1() {
//         console.log(this.name);
//     },
//     func2: () => {
//        console.log(this.name);
//     }
// }
// obj.func1();
// obj.func2();

// function ritu() {
//     console.log(this);    //window object
//     function riya() {
//         console.log(this)      //window object
//     }
//     riya()
// }
// ritu();

const obj = {
    xyz : function() {
        console.log(this)   //obj i.e refrence of parent obj
        function p() {
            console.log(this)   //print window object
            const obj2 = {
                name : "ritu",
                q() {
                    console.log(this)     //obj2 
                    const r = () => {
                        console.log(this)  //it is arrow fun and it is printing obj2 because 
                                          //this in arrow function behave accouring to it lecical parent
                       console.log("this is started now there are lots of thing to known");
                   }
                    r();
                },
                
            }
            obj2.q();
        }
        p()   
    }
}
obj.xyz()
//note :- "this" in arrow function behave accourding to its lecical parents not necessary it always point window object
           some time its pointing to object it because of lecical scoping 

---------------------------------------The Scope chain, Scope and Lexical Environment---------------------------------------

The scope chain is a way to link or provide a systematic access to all variables and other functions that 
the current execution context (function in this case) has access to





